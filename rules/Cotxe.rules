import java.time.ZonedDateTime

//rules to manage unused power
var test = false     //set to true to use the test items instead of the real ones
val MAX_POWER = 2000.0
val IDLE_POWER = 1 //an estimation of what it uses if the car is not connected, in W
val BLOCKED_POWER = 5.0 //below this power, the plug is considered not to be working, and therefore is switched off and ON after a few seconds
var long chargingWithoutExtraPowerTimeStart = 0
var String previousChargingState = ""


rule "Potencia disponible cotxe"
when
	Item Cotxe_AvailablePower received command
then
	val gestioAutoCotxe = GestioAutomaticaCotxe.state
	var requiredPower = 0.0
	if(gestioAutoCotxe == "auto" || gestioAutoCotxe == "grid"){
		logDebug("Cotxe.rules", "Received new power available for Cotxe auto")
	    val oldPowerState = Cotxe_AvailablePower.state
	    var availablePower = 0.0
	    if(oldPowerState != NULL){
	        availablePower = (oldPowerState as Number).doubleValue
	    }

	    var currentPower = 0.0
	    val currentPowerItem = Cotxe_Potencia_UserDisplay.state
	    if(currentPowerItem != NULL){
	        currentPower = (currentPowerItem as Number).doubleValue
	    }

	    var isCurrentlyOn = false
	    val switchState = CotxeEncesa_FV_Proxy.state
	    if(switchState ==ON ){
	        isCurrentlyOn = true
	    }

        if(isCurrentlyOn){
            //then the current power is what we are going to use
            if(availablePower >= currentPower){
                logDebug("Cotxe.rules", "The switch is currently on (using "+currentPower+"), there is enough available power ("+availablePower+")")
                requiredPower = currentPower
            }else{
                logDebug("Cotxe.rules", "The switch is currently on (using "+currentPower+"), there is NOT enough available power ("+availablePower+")")
                requiredPower = 0.0
            }
        }else{
            //then the IDLE_POWER is what we are going to use (or more, if the car is connected)
            //but we will only use it if there is enough available power for the connected car
             if(availablePower >= MAX_POWER){
                 logDebug("Cotxe.rules", "The switch is currently OFF and there is enough available power ("+availablePower+"), so required is not 0")
                requiredPower = IDLE_POWER
             }else{
                 //tehre is not enough available power, so there is no point in trying
                 logDebug("Cotxe.rules", "The switch is currently OFF but there is NOT enough available power ("+availablePower+") so required is 0")
                 requiredPower = 0.0
             }

        }

        logDebug("Cotxe.rules", "The power that the Cotxe will use is "+requiredPower)
	}else{
		logDebug("Cotxe.rules", "Received unused power, but Cotxe is manual, so ignoring it")
	}
	Cotxe_RequiredPower.sendCommand(requiredPower)
end

rule "update cotxe required power"
when
	Item Cotxe_RequiredPower received command
then
    logDebug("Cotxe.rules", "Required power updated, notifying the DestinationDeviceUpdated")
	DestinationDeviceUpdated.sendCommand("Cotxe")
end

rule "Apply power cotxe"
when
	Item Cotxe_ApplyChange received command
then
    val gestioAutoCotxe = GestioAutomaticaCotxe.state
    logDebug("Cotxe.rules", "Received command to apply the power")
    if(gestioAutoCotxe == "auto" || gestioAutoCotxe == "grid"){
        logDebug("Cotxe.rules", "Going to apply the required power")
        val requiredPowerState = Cotxe_RequiredPower.state
        var powerToApply = 0.0
        if(requiredPowerState != NULL){
            powerToApply = (requiredPowerState as Number).intValue
        }
        logDebug("Cotxe.rules", "The required power to apply is "+powerToApply)
        if(powerToApply > 0.0){
            logDebug("Cotxe.rules", "Turning ON the cotxe charger")
            CotxeEncesa_FV_Proxy.sendCommand(ON)
        }else{
            logDebug("Cotxe.rules", "Turning OFF the cotxe charger, as power to apply is 0.0")
            CotxeEncesa_FV_Proxy.sendCommand(OFF)
        }
        DestinationDeviceApplied.sendCommand("Cotxe")
    }else{
        logDebug("Cotxe.rules", "Gestio is not automatic, so not applying required power, but notifying as applied")
        Cotxe_UsedPower.sendCommand(0)
        DestinationDeviceApplied.sendCommand("Cotxe")
    }
end

rule "Minuts descarregant bateria FV"
when 
    Item Cotxe_Temps_Bateria changed
    or Item CotxeEncesa_FV_Proxy received command
then
    var ordreFV = receivedCommand
    if(ordreFV == null){
        ordreFV = CotxeEncesa_FV_Proxy.state
    }
    logDebug("Cotxe.rules", "Checking FV charge without extra power.")
    if(ordreFV == ON){
        logDebug("Cotxe.rules", "CotxeEncesa_FV_Proxy is ON, so doing nothing and just forwarding.")
        CotxeEncesa_FV_Decisor.sendCommand(ON)
    }else{
        val isCurrentlyOn = CotxeEncesa_FV_Decisor.state == ON
        if(isCurrentlyOn){
            logDebug("Cotxe.rules", "CotxeEncesa_FV_Proxy is set to OFF, but the FV decisor was ON, checking time ")
            val now = ZonedDateTime::now
            val nowMillis = now.toInstant().toEpochMilli()
            if(chargingWithoutExtraPowerTimeStart == 0){
                logDebug("Cotxe.rules", "Just happened now, starting timer")
                chargingWithoutExtraPowerTimeStart = nowMillis
            }else{
                val minutsState = Cotxe_Temps_Bateria.state
                var minuts = 1
                if(minutsState != NULL){
                    minuts = (minutsState as Number).intValue
                }
                logDebug("Cotxe.rules", "The limit is set to "+minuts+" minutes")
                val maxChargingWithoutExtraPowerTime = 1000L * 60 * minuts

                if(nowMillis - chargingWithoutExtraPowerTimeStart >= maxChargingWithoutExtraPowerTime){
                    logInfo("Cotxe.rules", "The time using batteries exceeded, turning off")
                    CotxeEncesa_FV_Decisor.sendCommand(OFF)
                    chargingWithoutExtraPowerTimeStart = 0L
                }else{
                    logDebug("Cotxe.rules", "The time using batteries has not been reached yet, keeping ON")
                    CotxeEncesa_FV_Decisor.sendCommand(ON)
                }
            }
        }else{
            logDebug("Cotxe.rules", "CotxeEncesa_FV_Proxy is set to OFF, and the FV decisor was OFF, so nothing to do")
            CotxeEncesa_FV_Decisor.sendCommand(OFF)
            chargingWithoutExtraPowerTimeStart = 0L
        }
    }
    
end

//rules not to manage unused power
rule "Canvi gestio Cotxe"
when
    Item GestioAutomaticaCotxe received command
then
    val gestioAutoCotxe = receivedCommand
    if(gestioAutoCotxe == "manual"){
        chargingWithoutExtraPowerTimeStart = 0L //this restarts the counter for keeping the switch ON without for some time
        logDebug("Cotxe.rules", "Gestio Cotxe changed to manual. Currently switched off")
        CotxeEncesa_Manual_Proxy.sendCommand(OFF)
        //we are not using unused power, because all is manual.
        Cotxe_UsedPower.sendCommand(0)
    }else{
        chargingWithoutExtraPowerTimeStart = 0L //this restarts the counter for keeping the switch ON without unused power
        logDebug("Cotxe.rules", "Gestio Cotxe changed to auto or grid, starting from current used power")
        CotxeEncesaManual.postUpdate(OFF)
        var currentPower = 0.0
        val currentPowerItem = Cotxe_Potencia_UserDisplay.state
        if(currentPowerItem != NULL){
            currentPower = (currentPowerItem as Number).doubleValue
        }
        Cotxe_UsedPower.sendCommand(currentPower)
    }
end

//RULES FOR MANUAL CHARGING

//TODO make the manual also set a limit on the battery level.

rule "Canvi manual Cotxe"
when 
    Item CotxeEncesaManual received command
then
    val gestioAutoCotxe = GestioAutomaticaCotxe.state
    if(gestioAutoCotxe != "manual"){
        logDebug("Cotxe.rules", "Gestio Cotxe is auto. Changing the power has no effects")
        CotxeEncesaManual.postUpdate(OFF)
    }else{
        logDebug("Cotxe.rules", "Gestio Cotxe is manual. Changing the cotxe charger to " + receivedCommand)
        if (receivedCommand == ON) {
            CotxeEncesa_Manual_Proxy.sendCommand(ON)  //turn it on or off
        }else{
            CotxeEncesa_Manual_Proxy.sendCommand(OFF) 
        }
        //we are not using unused power, because all is manual.
        Cotxe_UsedPower.sendCommand(0+"")
    }
end

//RULES FOR GRID CHARGING

//TODO allow to configure if charging can go with PLA and VALL, or always

rule "Grid connected and charge car"
when
    Item GridPriceCurrent changed
    or Item GestioAutomaticaCotxe changed
    or Item CotxeEncesa_Xarxa_Tarifes changed
    or Item CotxeEncesa_FV_Decisor changed
then
    val gestioAutoCotxe = GestioAutomaticaCotxe.state
    val decisorFVon = CotxeEncesa_FV_Decisor.state == ON
    if(gestioAutoCotxe == "grid" && !decisorFVon){
        val tarifa = GridPriceCurrent.state
        if(tarifa  == "vall"){
            logDebug("Cotxe.rules", "Tarifa is "+tarifa+", gestio is grid, so starting to turn on carregador")
            CotxeEncesa_Xarxa_Proxy.sendCommand(ON) 
        }else{
            val tarifaActivacio = CotxeEncesa_Xarxa_Tarifes.state
            if(tarifaActivacio == "all"){
                logDebug("Cotxe.rules", "Tarifa enabled is "+tarifaActivacio+", gestio is grid, so starting to turn on carregador")
                CotxeEncesa_Xarxa_Proxy.sendCommand(ON) 
            }else if(tarifaActivacio == "pla" && tarifa == "pla"){
                logDebug("Cotxe.rules", "Tarifa is "+tarifa+" and enabled is "+tarifaActivacio+", gestio is grid, so starting to turn on carregador")
                CotxeEncesa_Xarxa_Proxy.sendCommand(ON) 
            }else{
                logDebug("Cotxe.rules", "Tarifa is "+tarifa+" and enabled is "+tarifaActivacio+", gestio is grid, so stopping carregador")
                CotxeEncesa_Xarxa_Proxy.sendCommand(OFF) 
            }
        }
    }else{
       logDebug("Cotxe.rules", "Tarifa or tarifa to enable gird changed, but gestio is not grid ("+gestioAutoCotxe
            +") or FV is on ("+decisorFVon+"), turning charging from grid off")
       CotxeEncesa_Xarxa_Proxy.sendCommand(OFF)
    }
end

rule "Start Grid car charging"
when
    Item CotxeEncesa_Xarxa_Proxy changed
    or Item GridStatus changed
    or Item CotxeConnexio_Status changed
    or Item AlarmGridConnection changed
then
    val encesaXarxa = CotxeEncesa_Xarxa_Proxy.state == ON

    logDebug("Cotxe.rules", "Grid proxy or grid status changed, checking what to do")
    //si el cotxe no s'ha d'encendre per xarxa, posa'l a off
    if(!encesaXarxa){
        logDebug("Cotxe.rules", "Grid proxy is off so turning off charger and disconnectig grid for this reason")
        CotxeEncesa_Xarxa_Decisor.sendCommand(OFF)
        GridAutomaticCarSwitch.sendCommand(OFF)
    }else{
        logDebug("Cotxe.rules", "Grid proxy is ON, checking grid and charger connection")
        val xarxaConnectada = GridStatus.state == ON

        val statusItem = CotxeConnexio_Status.state
        var statusCarregador = "apagat"
        if(statusItem != NULL){
            statusCarregador = statusItem.toString
        }

        if(statusCarregador == "apagat"){
            logDebug("Cotxe.rules", "The charger is not enabled, so first enable it without grid")
            GridAutomaticCarSwitch.sendCommand(OFF)
            CotxeEncesa_Xarxa_Decisor.sendCommand(ON)
        }else if(statusCarregador == "connectat"){
            logDebug("Cotxe.rules", "The charger is without car, so keep it without grid")
            GridAutomaticCarSwitch.sendCommand(OFF)
            CotxeEncesa_Xarxa_Decisor.sendCommand(ON)
        }else{
            logDebug("Cotxe.rules", "The charger is blocked or charging. Check the grid")
            if(xarxaConnectada){
                logDebug("Cotxe.rules", "Grid connected and proxy ON, turing ON charger")
                CotxeEncesa_Xarxa_Decisor.sendCommand(ON)
            }else{
                logDebug("Cotxe.rules", "Grid NOT connected and charger charging or blocked, checking alarm for connection")
                val alarmGridConnection = AlarmGridConnection.state == ON
                if(alarmGridConnection){
                    logWarn("Cotxe.rules", "Alarm is ON for grid connection, so disconnecting just in case")
                    CotxeEncesa_Xarxa_Decisor.sendCommand(OFF)
                }else{
                    logDebug("Cotxe.rules", "Grid NOT connected and charger charging or blocked, alarm is off, so turning on grid")
                    GridAutomaticCarSwitch.sendCommand(ON)
                }
            }
        }
        
    }
end


rule "Activar o desactivar carregador per alguna de les 3 vies"
when
    Item CotxeEncesa_Xarxa_Decisor changed
    or Item CotxeEncesa_Manual_Proxy changed
    or Item CotxeEncesa_FV_Decisor changed
then
    logDebug("Cotxe.rules", "Changed one of the ways to plug the car, checking if to turn it")
    if(CotxeEncesa_Manual_Proxy.state == ON){
        logDebug("Cotxe.rules", "Manual is ON, turning it on")
        CotxeEncesa_Restart_Proxy.sendCommand(ON)
    }else if(CotxeEncesa_Xarxa_Decisor.state == ON){
        logDebug("Cotxe.rules", "Xarxa is ON, turning it on")
        CotxeEncesa_Restart_Proxy.sendCommand(ON)
    }else if(CotxeEncesa_FV_Decisor.state == ON){
        logDebug("Cotxe.rules", "FV is ON, turning it on")
        CotxeEncesa_Restart_Proxy.sendCommand(ON)
    }else{
        logDebug("Cotxe.rules", "None is ON, turning it OFF")
        CotxeEncesa_Restart_Proxy.sendCommand(OFF)
    }
end

//RULES TO MANAGE BLOCKED CHARGER

rule "Update car charging status"
when
    Item Cotxe_Potencia_Sensor received update
then
    val potenciaSensor = Cotxe_Potencia_Sensor.state
    var potencia = 0.0
    if(potenciaSensor != NULL){
        potencia = (potenciaSensor as Number).doubleValue
    }
    logDebug("Cotxe.rules", "Going to check connexio status")
    var newStatus = "apagat"
    if(potencia <= 0.0){
        logDebug("Cotxe.rules", "Connexio status to disabled as power is 0.0")
        newStatus = "apagat"
    }else if(potencia <= IDLE_POWER){
        logDebug("Cotxe.rules", "Connexio status to no_car as power is < IDLE_POWER ("+potencia+")")
        newStatus = "connectat"
    }else if(potencia <= BLOCKED_POWER){
        logInfo("Cotxe.rules", "Connexio status to blocked as power is < BLOCKED_POWER ("+potencia+")")
        newStatus = "bloquejat"
    }else{
        logDebug("Cotxe.rules", "Connexio status to charging as power is ("+potencia+")")
        newStatus = "carregant"
    }

    //debounce on two measures, to avoid understanding blocked when turning on
    if(previousChargingState == newStatus){
        logInfo("Cotxe.rules", "Connexio status changing to "+newStatus+" as it has not changed ("+potencia+")")
        CotxeConnexio_Status.sendCommand(newStatus)  
    }else{
        logDebug("Cotxe.rules", "Connexio status just changed so waiting to confirm")
        previousChargingState = newStatus
    }

end 

rule "Update car icon"
when
    Item CotxeConnexio_Status changed
then
    val status = CotxeConnexio_Status.state.toString
    CotxeTitle.sendCommand(status + "")
end

rule "Restart blocked charger"
when
    Item CotxeEncesa_Restart_Proxy changed 
    or Item CotxeConnexio_Status changed
then
    logDebug("Cotxe.rules", "Restart proxy or used power changed. Cheking if it needs restart")
    val statusProxy = CotxeEncesa_Restart_Proxy.state
    if(statusProxy == ON){
        logDebug("Cotxe.rules", "Restart proxy: Status is ON, so checking the status to decide if to restart")
        val statusItem = CotxeConnexio_Status.state
        var status = "disabled"
        if(statusItem != NULL){
            status = statusItem.toString
        }
    
        if(status == "apagat"){
            logDebug("Cotxe.rules", "Restart proxy: Status is ON and connection is disabled, so probably just turned OFF. Turning it ON now")
            CotxeEncesa_Control_Proxy.sendCommand(ON)
        }else if(status == "connectat"){
            logDebug("Cotxe.rules", "Restart proxy: Status is ON and connection is no_car, keeping it ON as car is not connected")
            CotxeEncesa_Control_Proxy.sendCommand(ON)
        }else if(status == "bloquejat"){
            logInfo("Cotxe.rules", "Restart proxy: Status is ON and connection is blocked, turning it OFF")
            CotxeEncesa_Control_Proxy.sendCommand(OFF)
        }else{
            logDebug("Cotxe.rules", "Restart proxy: Status is ON and connection is charging, keeping it ON")
            CotxeEncesa_Control_Proxy.sendCommand(ON)   
        }
    }else{
        logDebug("Cotxe.rules", "Restart proxy: As status is not ON turning it OFF")
        CotxeEncesa_Control_Proxy.sendCommand(OFF)
    }
end

rule "Activar o desactivar carregador Cotxe"
when
    Item CotxeEncesa_Control_Proxy changed
then
    logDebug("Cotxe.rules", "The cotxe plug will be set to "+ newState)
    if (newState == ON) {
        logInfo("Cotxe.rules", "The cotxe charger changed to ON as it has been turned on")
        CotxeEncesa_Control.sendCommand(ON)  //turn it on or off
    }else{
        logInfo("Cotxe.rules", "The cotxe charger changed to OFF as it has been turned off")
        CotxeEncesa_Control.sendCommand(OFF) 
    }  
end

//RULES FOR MANAGING SENSOR DATA OF THE CHARGER

rule "Canvi potencia cotxe"
when
    Item Cotxe_Potencia_UserDisplay received command
then
    logDebug("Cotxe.rules", "The cotxe is now using "+ receivedCommand +", updating UsedPower")
    Cotxe_UsedPower.sendCommand(receivedCommand)
end

rule "Canvi potencia cotxe sensor"
when
    Item Cotxe_Potencia_Sensor changed
then
    val potenciaSensor = Cotxe_Potencia_Sensor.state
    var potencia = 0.0
    if(potenciaSensor != NULL){
        potencia = (potenciaSensor as Number).doubleValue
        if(potencia >= 200.0){
            logDebug("Cotxe.rules", "The cotxe title changed to CHARGING as there is potencia : "+potencia)
            CotxeTitle.sendCommand("CHARGING")
        }else{
            logDebug("Cotxe.rules", "The cotxe title NOT changed to CHARGING as there is NOT potencia : "+potencia)
        }
    }
    logDebug("Cotxe.rules", "The cotxe power sensor received "+ potencia)
    Cotxe_Potencia_UserDisplay.sendCommand(potencia)
end

rule "lectura sensor cotxe"
when
    Item Cotxe_Sensor_Lectura received update
then
    var rawData = Cotxe_Sensor_Lectura.state.toString
    logDebug("Cotxe.rules", "Received new info from sensor cotxe "+ rawData)
    if(rawData !== null){
        logDebug("Cotxe.rules", "Going to get power")
        var String data = transform("JSONPATH", "$.power", rawData)
        if(data=== null || data.equals(rawData)){
            logError("Cotxe.rules","No s'ha pogut obtenir la potencia: "+ rawData +", no s'ha actualitzat")
        }else{
            try {
                val Float power=Float::parseFloat(data)
                Cotxe_Potencia_Sensor.postUpdate(power)
                logInfo("Cotxe.rules", "Updated power from sensor: Power = "+ power)
            } catch (Exception e) {
                logError("Cotxe.rules","La pot del cotxe no es pot convertir a numero: "+ data +", no s'ha actualitzat")
            }
        }

        data = transform("JSONPATH", "$.energy", rawData)
        if(data=== null || data.equals(rawData)){
            logError("Cotxe.rules","No s'ha pogut obtenir la energia: "+ rawData +", no s'ha actualitzat")
        }else{
            try {
                val Float energy=Float::parseFloat(data)
                Cotxe_Energia_Sensor.postUpdate(energy)
                logInfo("Cotxe.rules", "Updated energy from sensor: energy = "+energy)
            } catch (Exception e) {
                logError("Cotxe.rules","La energia del cotxe no es pot convertir a numero: "+ data +", no s'ha actualitzat")
            }
        }
        
    }
end

rule "Energia avui cotxe"
when
    Item Cotxe_Energia_Sensor changed
then
    val energiaTotalSensor = Cotxe_Energia_Sensor.state
    var Float energiaTotal = 0
    if(energiaTotalSensor != NULL){
        energiaTotal = (energiaTotalSensor as Number).doubleValue
    }
    val energiaAhirSensor = Cotxe_Energia_Ahir.state
    var Float energiaAhir = 0
    if(energiaAhirSensor != NULL){
        energiaAhir = (energiaAhirSensor as Number).doubleValue
    }
    
    val energiaAvui = energiaTotal - energiaAhir
    //dirty temporal hack to identify why sometimes the energia avui contains the energia total
    if(energiaAvui > 100000){
        logError("Cotxe.rules", "Too big Energia avui "+energiaAvui+": total = "+ energiaTotal + ", ahir = "+ energiaAhir)
    }else{
        logInfo("Cotxe.rules", "Calculated energia avui "+energiaAvui+": total = "+ energiaTotal + ", ahir = "+ energiaAhir)
        Cotxe_Energia_Avui.postUpdate(energiaAvui)
    }
end

rule "Reset energy today cotxe"
when
    Time cron "0 0 0 ? * * *"
then
    val energiaTotalSensor = Cotxe_Energia_Sensor.state
    var energiaTotal = 0
    if(energiaTotalSensor != NULL){
        energiaTotal = (energiaTotalSensor as Number).doubleValue
    }
    logInfo("Cotxe.rules", "Resetting energia ahir i avui:  ahir = "+ energiaTotal)
    Cotxe_Energia_Ahir.postUpdate(energiaTotal)
    Cotxe_Energia_Avui.postUpdate(0)
end

